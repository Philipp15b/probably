r"""
------------------------
Characteristic Functions
------------------------

Want to calculate the characteristic function of a program?
You're in the right module!

.. autoclass:: LoopCFTransformer
.. autofunction:: one_loop_cf_transformer
.. autofunction:: general_cf_transformer

"""
import functools
from copy import deepcopy
from typing import Dict, List, Sequence, Union
import sympy

import attr

from probably.util.ref import Mut

from .ast import (AsgnInstr, Binop, BinopExpr, CategoricalExpr, ChoiceInstr,
                  Expr, FloatLitExpr, RealLitExpr, IfInstr, Instr, Program,
                  SkipInstr, SubstExpr, TickExpr, TickInstr, DUniformExpr, CUniformExpr, Unop,
                  UnopExpr, Var, VarExpr, WhileInstr)
from .substitute import substitute_expr
from .syntax import check_is_one_big_loop
from .walk import Walk, walk_expr


def loopfree_cf(instr: Union[Instr, Sequence[Instr]],
                precf: Expr) -> Expr:
    """
    Build the characteristic function as an expression. See also
    :func:`loopfree_cf_transformer`.

    .. warning::
        Loops are not supported by this function.

    .. todo::
        At the moment, the returned expression is a tree and not a DAG.
        Subexpressions that occur multiple times are *deepcopied*, even though that
        is not strictly necessary. For example, ``jump := unif(0,1); t := t + 1``
        creates an AST where the second assignment occurs twice, as different Python objects,
        even though the two substitutions generated by the *uniform* expression could reuse it.
        We do this because the :mod:`probably.pgcl.substitute` module cannot yet handle non-tree ASTs.

    .. doctest::

        >>> from .parser import parse_pgcl
        >>> from .ast import FloatLitExpr, VarExpr

        >>> program = parse_pgcl("bool a; bool x; if (a) { x := 1 } {}")
        >>> res = loopfree_cf(program.instructions, FloatLitExpr("1.0"))
        >>> str(res)
        '([a] * ((1.0)[x/1])) + ([not a] * 1.0)'

        >>> program = parse_pgcl("bool a; bool x; if (a) { { x := 1 } [0.5] {x := 2 } } {} x := x + 1")
        >>> res = loopfree_cf(program.instructions, VarExpr("x"))
        >>> str(res)
        '([a] * (((((x)[x/x + 1])[x/1]) * 0.5) + ((((x)[x/x + 1])[x/2]) * (1.0 - 0.5)))) + ([not a] * ((x)[x/x + 1]))'

        >>> program = parse_pgcl("nat x; x := unif(1, 4)")
        >>> res = loopfree_cf(program.instructions, VarExpr("x"))
        >>> str(res)
        '(((1/4 * ((x)[x/1])) + (1/4 * ((x)[x/2]))) + (1/4 * ((x)[x/3]))) + (1/4 * ((x)[x/4]))'

        >>> program = parse_pgcl("bool x; x := true : 0.5 + false : 0.5;")
        >>> res = loopfree_cf(program.instructions, VarExpr("x"))
        >>> str(res)
        '(0.5 * ((x)[x/true])) + (0.5 * ((x)[x/false]))'

    Args:
        instr: The instruction to calculate the cf for, or a list of instructions.
        precf: The precf.
    """

    if isinstance(instr, list):
        return functools.reduce(lambda x, y: loopfree_cf(y, x),
                                instr, precf)

    if isinstance(instr, SkipInstr):
        return precf

    if isinstance(instr, WhileInstr):
        raise Exception("While instruction not supported for cf generation")

    if isinstance(instr, IfInstr):
        satisfying_part = prec.filter(guard)
        non_sat_part = precf.filter(not guard)

        true_block = loopfree_cf(instr.true, satisfying_part)
        false_block = loopfree_cf(instr.false, non_sat_part)

        false = BinopExpr(
            Binop.TIMES, UnopExpr(Unop.IVERSON,
                                  UnopExpr(Unop.NEG, instr.cond)), false_block)
        return BinopExpr(Binop.PLUS, true, false)

    if isinstance(instr, AsgnInstr):
        if isinstance(instr.rhs, (DUniformExpr, CategoricalExpr)):
            distribution = instr.rhs.distribution()
            branches = [
                BinopExpr(
                    Binop.TIMES, prob,
                    SubstExpr({instr.lhs: expr}, deepcopy(precf)))
                for prob, expr in distribution
            ]
            return functools.reduce(lambda x, y: BinopExpr(Binop.PLUS, x, y),
                                    branches)

        subst: Dict[Var, Expr] = {instr.lhs: instr.rhs}
        return SubstExpr(subst, precf)

    if isinstance(instr, ChoiceInstr):
        lhs_block = loopfree_cf(instr.lhs, precf)
        rhs_block = loopfree_cf(instr.rhs, deepcopy(precf))
        lhs = BinopExpr(Binop.TIMES, lhs_block, instr.prob)
        rhs = BinopExpr(
            Binop.TIMES, rhs_block,
            BinopExpr(Binop.MINUS, FloatLitExpr("1.0"), instr.prob))
        return BinopExpr(Binop.PLUS, lhs, rhs)

    if isinstance(instr, TickInstr):
        return BinopExpr(Binop.PLUS, precf, TickExpr(instr.expr))

    raise Exception("illegal instruction")
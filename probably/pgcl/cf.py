r"""
------------------------
Characteristic Functions
------------------------

Want to calculate the characteristic function of a program?
You're in the right module!

.. autoclass:: LoopCFTransformer
.. autofunction:: one_loop_cf_transformer
.. autofunction:: general_cf_transformer

"""
import functools
from copy import deepcopy
from typing import Dict, List, Sequence, Union

import attr

from probably.util.ref import Mut

from .ast import (AsgnInstr, Binop, BinopExpr, CategoricalExpr, ChoiceInstr,
                  Expr, FloatLitExpr, RealLitExpr, IfInstr, Instr, Program,
                  SkipInstr, SubstExpr, TickExpr, TickInstr, DUniformExpr, CUniformExpr, Unop,
                  UnopExpr, Var, VarExpr, WhileInstr)
from .substitute import substitute_expr
from .syntax import check_is_one_big_loop
from .walk import Walk, walk_expr


def loopfree_cf(instr: Union[Instr, Sequence[Instr]],
                precf: Expr) -> Expr:
    """
    Build the characteristic function as an expression. See also
    :func:`loopfree_cf_transformer`.

    .. warning::
        Loops are not supported by this function.

    .. todo::
        At the moment, the returned expression is a tree and not a DAG.
        Subexpressions that occur multiple times are *deepcopied*, even though that
        is not strictly necessary. For example, ``jump := unif(0,1); t := t + 1``
        creates an AST where the second assignment occurs twice, as different Python objects,
        even though the two substitutions generated by the *uniform* expression could reuse it.
        We do this because the :mod:`probably.pgcl.substitute` module cannot yet handle non-tree ASTs.

    .. doctest::

        >>> from .parser import parse_pgcl
        >>> from .ast import FloatLitExpr, VarExpr

        >>> program = parse_pgcl("bool a; bool x; if (a) { x := 1 } {}")
        >>> res = loopfree_cf(program.instructions, FloatLitExpr("1.0"))
        >>> str(res)
        '([a] * ((1.0)[x/1])) + ([not a] * 1.0)'

        >>> program = parse_pgcl("bool a; bool x; if (a) { { x := 1 } [0.5] {x := 2 } } {} x := x + 1")
        >>> res = loopfree_cf(program.instructions, VarExpr("x"))
        >>> str(res)
        '([a] * (((((x)[x/x + 1])[x/1]) * 0.5) + ((((x)[x/x + 1])[x/2]) * (1.0 - 0.5)))) + ([not a] * ((x)[x/x + 1]))'

        >>> program = parse_pgcl("nat x; x := unif(1, 4)")
        >>> res = loopfree_cf(program.instructions, VarExpr("x"))
        >>> str(res)
        '(((1/4 * ((x)[x/1])) + (1/4 * ((x)[x/2]))) + (1/4 * ((x)[x/3]))) + (1/4 * ((x)[x/4]))'

        >>> program = parse_pgcl("bool x; x := true : 0.5 + false : 0.5;")
        >>> res = loopfree_cf(program.instructions, VarExpr("x"))
        >>> str(res)
        '(0.5 * ((x)[x/true])) + (0.5 * ((x)[x/false]))'

    Args:
        instr: The instruction to calculate the cf for, or a list of instructions.
        precf: The precf.
    """

    if isinstance(instr, list):
        return functools.reduce(lambda x, y: loopfree_cf(y, x),
                                instr, precf)

    if isinstance(instr, SkipInstr):
        return precf

    if isinstance(instr, WhileInstr):
        raise Exception("While instruction not supported for cf generation")

    if isinstance(instr, IfInstr):
        true_block = loopfree_cf(instr.true, precf)
        false_block = loopfree_cf(instr.false, deepcopy(precf))
        true = BinopExpr(Binop.TIMES, UnopExpr(Unop.IVERSON, instr.cond),
                         true_block)
        false = BinopExpr(
            Binop.TIMES, UnopExpr(Unop.IVERSON,
                                  UnopExpr(Unop.NEG, instr.cond)), false_block)
        return BinopExpr(Binop.PLUS, true, false)

    if isinstance(instr, AsgnInstr):
        if isinstance(instr.rhs, (DUniformExpr, CategoricalExpr)):
            distribution = instr.rhs.distribution()
            branches = [
                BinopExpr(
                    Binop.TIMES, prob,
                    SubstExpr({instr.lhs: expr}, deepcopy(precf)))
                for prob, expr in distribution
            ]
            return functools.reduce(lambda x, y: BinopExpr(Binop.PLUS, x, y),
                                    branches)

        subst: Dict[Var, Expr] = {instr.lhs: instr.rhs}
        return SubstExpr(subst, precf)

    if isinstance(instr, ChoiceInstr):
        lhs_block = loopfree_cf(instr.lhs, precf)
        rhs_block = loopfree_cf(instr.rhs, deepcopy(precf))
        lhs = BinopExpr(Binop.TIMES, lhs_block, instr.prob)
        rhs = BinopExpr(
            Binop.TIMES, rhs_block,
            BinopExpr(Binop.MINUS, FloatLitExpr("1.0"), instr.prob))
        return BinopExpr(Binop.PLUS, lhs, rhs)

    if isinstance(instr, TickInstr):
        return BinopExpr(Binop.PLUS, precf, TickExpr(instr.expr))

    raise Exception("illegal instruction")


@attr.s
class CFTransformer:
    r"""
    Wraps an expectation :math:`f` (represented by
    :class:`probably.pgcl.ast.Expr`) and holds a reference to a variable
    :math:`v`. Together they represent an *expectation transformer*, a function
    :math:`\Phi : \mathbb{E} \to \mathbb{E}` mapping expectations to
    expectations.

    An expectation is applied (:math:`\Phi(g)`) by replacing :math:`f` by
    :math:`g`.

    The :mod:`probably.pgcl.simplify` module can translate expectation
    transformers into *summation normal form*. See
    :class:`probably.pgcl.simplify.SnfCFTransformer` and
    :func:`probably.pgcl.simplify.normalize_expectation_transformer`.
    """

    variable: Var = attr.ib()
    """The variable occuring in :data:`expectation`. Must not occur in the
    program."""

    expectation: Expr = attr.ib()

    @property
    def _expectation_ref(self) -> Mut[Expr]:
        def write_expectation(value):
            self.expectation = value
        return Mut(lambda: self.expectation, write_expectation)

    def substitute(self) -> 'CFTransformer':
        """
        Apply all :class:`probably.pgcl.ast.SubstExpr` using
        :func:`probably.pgcl.substitute.substitute_expr`, keeping
        :data:`variable` symbolic.

        Returns ``self`` for convenience.
        """
        substitute_expr(self._expectation_ref, symbolic=frozenset([self.variable]))
        return self

    def apply(self, expectation: Expr, substitute: bool=True) -> Expr:
        """
        Transform the given expectation with this expectation transformer.

        The result is the modified internal expression with the variable
        replaced by the post-expectation, i.e. ``self.expectation``.

        **Calling this method will change this object!**

        .. doctest::

            >>> from .parser import parse_pgcl
            >>> program = parse_pgcl("x := 3")
            >>> cf = loopfree_cf_transformer(program, program.instructions)
            >>> print(cf)
            λ𝑋. (𝑋)[x/3]
            >>> print(cf.apply(VarExpr("x")))
            3

        Args:
            substitute: Whether to apply all remaining substitutions in the expectation.
        """
        # What would be very wrong:
        #   expr: Expr = SubstExpr({self.variable: expectation}, self.expectation)
        #   expectation_ref = Mut.alloc(expr)
        #   substitute_expr(expectation_ref)
        #   return expectation_ref.val
        #
        # This would first apply inner substitutions, and then replace the
        # post-expectation. Consider the transformer "λ𝑋. (𝑋)[x/3]". Consider
        # the post-expectation "x". Applying a substitution as above would
        # result in "λ𝑋. (𝑋)[x/3][𝑋/x]" - after reduction, we'd get the
        # result "x" instead of the the correct "3"!
        #
        # Instead, simply search and replace the post-expectation in the expression.
        for expr_ref in walk_expr(Walk.DOWN, self._expectation_ref):
            expr = expr_ref.val
            if isinstance(expr, VarExpr) and expr.var == self.variable:
                expr_ref.val = expectation
        # Apply all remaining substitutions for convenience.
        if substitute:
            substitute_expr(self._expectation_ref, deepcopy=True)
        return self.expectation


    def __str__(self) -> str:
        return f"λ{self.variable}. {self.expectation}"


def loopfree_cf_transformer(program: Program,
                            instr: Union[Instr, Sequence[Instr]],
                            variable: str = '𝑋',
                            substitute: bool = True) -> CFTransformer:
    """
    Generalized version of :func:`loopfree_cf` that returns an
    :class:`CFTransformer`.

    Args:
        variable: Optional name for the variable to be used for the transformer. Must not occur elsewhere in the program.
        substitute: Whether to call :meth:`CFTransformer.substitute` on the ``body``.
    """
    assert variable not in program.variables
    expectation = loopfree_cf(instr, VarExpr(variable))
    transformer = CFTransformer(variable, expectation)
    if substitute:
        transformer.substitute()
    return transformer


@attr.s
class LoopCFTransformer:
    r"""
    The expectation *transformer* for a pGCL program with **exactly one loop and
    optional initialization assignments before the loop**.
    See :py:func:`one_loop_cf`.

    A loop's expectation transformer is represented by the initialization
    assignments themselves, an expectation transformer for the body, and a
    :data:`done` term which is the expectation for loop termination.

    Note that :data:`done` is not represented by an expectation transformer, but
    rather just an expectation (:class:`probably.pgcl.ast.Expr`). This is
    because the term in the weakest pre-expectation semantics for termination of
    the while loop never contains the post-expectation :math:`f` (it is just
    multiplied with it). A simpler representation allows for more convenient
    further use. The :math:`\mathrm{cf}` semantics of a ``while`` loop are shown
    below:

    .. math::

        \mathrm{cf}\llbracket{}\mathtt{while} (b) \{ C \}\rrbracket(f) = \mathrm{lfp}~X.~ \underbrace{[b] \cdot \mathrm{cf}\llbracket{}C\rrbracket{}(X)}_{\text{body}} + \underbrace{[\neg b]}_{\text{done}} \cdot f

    .. doctest::

        >>> from .parser import parse_pgcl
        >>> program = parse_pgcl("bool x; x := true; while (x) { x := false }")
        >>> transformer = one_loop_cf_transformer(program, program.instructions)
        >>> print(transformer)
        x := true;
        λ𝐹. lfp 𝑋. [x] * ((𝑋)[x/false]) + [not x] * 𝐹
        >>> print(repr(transformer))
        LoopCFTransformer(init=[AsgnInstr(lhs='x', rhs=BoolLitExpr(True))], body=CFTransformer(variable='𝑋', expectation=BinopExpr(operator=Binop.TIMES, lhs=UnopExpr(operator=Unop.IVERSON, expr=VarExpr('x')), rhs=SubstExpr(subst={'x': BoolLitExpr(False)}, expr=VarExpr('𝑋')))), done=UnopExpr(operator=Unop.IVERSON, expr=UnopExpr(operator=Unop.NEG, expr=VarExpr('x'))))
    """

    init: List[AsgnInstr] = attr.ib()
    """Initial assignments before the loop."""
    body: CFTransformer = attr.ib()
    """The expectation transformer for the loop's body."""
    done: Expr = attr.ib()
    """The expectation for when the loop is done."""
    def __str__(self) -> str:
        assignments = " ".join((str(assignment) for assignment in self.init))
        if len(assignments) != 0:
            assignments += "\n"
        # possibly assert that 𝐹 is not in the program?
        return f'{assignments}λ𝐹. lfp {self.body.variable}. {self.body.expectation} + {self.done} * 𝐹'


def one_loop_cf_transformer(
        program: Program,
        instr: Union[Instr, List[Instr]],
        variable: str = '𝑋',
        substitute: bool=True) -> LoopCFTransformer:
    """
    Calculate the weakest pre-expectation transformer of a program that consists
    of exactly one while loop with some optional assignments at the beginning.
    That means the only supported programs are of the following form:

    .. code-block::

        x := e1
        y := e2
        while (cond) { .. }

    .. doctest::

        >>> from .parser import parse_pgcl

        >>> program = parse_pgcl("bool x; bool y; while(x) { { x := true } [0.5] { x := y } }")
        >>> print(one_loop_cf_transformer(program, program.instructions))
        λ𝐹. lfp 𝑋. [x] * ((((𝑋)[x/true]) * 0.5) + (((𝑋)[x/y]) * (1.0 - 0.5))) + [not x] * 𝐹

        >>> program = parse_pgcl("bool x; while(x) { if (x) { x := false } {x := true } }")
        >>> print(one_loop_cf_transformer(program, program.instructions))
        λ𝐹. lfp 𝑋. [x] * (([x] * ((𝑋)[x/false])) + ([not x] * ((𝑋)[x/true]))) + [not x] * 𝐹

    Args:
        variable: Optional name for the variable to be used for the transformer. Must not occur elsewhere in the program.
        substitute: Whether to call :meth:`CFTransformer.substitute` on the ``body``.
    """
    # avoid a cyclic import
    from .simplify import simplifying_neg  # pylint: disable=import-outside-toplevel,cyclic-import

    # extract assignments and the loop from the program
    instrs = list(instr) if isinstance(instr, list) else [instr]
    init: List[AsgnInstr] = []
    while len(instrs) > 0 and isinstance(instrs[0], AsgnInstr):
        next_init = instrs.pop(0)
        assert isinstance(next_init, AsgnInstr)  # mypy is a bit dumb here
        init.append(next_init)
    loop = instrs.pop(0)
    err = "Program must consist of only instructions and a single while loop"
    assert len(instrs) == 0, err
    assert isinstance(loop, WhileInstr), err

    # weakest pre-expectation of the loop body
    body = loopfree_cf_transformer(program, loop.body, variable=variable, substitute=substitute)
    body.expectation = BinopExpr(Binop.TIMES, UnopExpr(Unop.IVERSON, loop.cond), body.expectation)

    # weakest pre-expectation of the done term
    done = UnopExpr(Unop.IVERSON, simplifying_neg(loop.cond))

    return LoopCFTransformer(init, body, done)


def general_cf_transformer(program: Program, substitute: bool=True) -> LoopCFTransformer:
    """
    Calculate the weakest pre-expectation transformer for any pGCL program. For
    programs that consist of one big loop (see :ref:`one_big_loop`),
    :func:`one_loop_cf_transformer` is invoked directly. All other programs are
    run through :func:`probably.pgcl.cfg.program_one_big_loop` first and then
    :func:`one_loop_cf_transformer` is used. This will introduce a new,
    additional variable for the program counter.

    .. doctest::

        >>> from .parser import parse_pgcl

        >>> program = parse_pgcl("bool x; while(x) { while (y) {} }")
        >>> print(general_cf_transformer(program))
        pc := 1;
        λ𝐹. lfp 𝑋. [not (pc = 0)] * (([pc = 1] * (([x] * ((𝑋)[pc/2])) + ([not x] * ((𝑋)[pc/0])))) + ([not (pc = 1)] * (([y] * ((𝑋)[pc/2])) + ([not y] * ((𝑋)[pc/1]))))) + [pc = 0] * 𝐹

    Args:
        substitute: Whether to call :meth:`CFTransformer.substitute` on the ``body``.
    """
    # avoid a cyclic import
    from .cfg import \
        program_one_big_loop  # pylint: disable=import-outside-toplevel,cyclic-import

    one_big_loop_err = check_is_one_big_loop(program.instructions)
    if one_big_loop_err is None:
        return one_loop_cf_transformer(program, program.instructions)
    program = program_one_big_loop(program, pc_var='pc')
    return one_loop_cf_transformer(program, program.instructions, substitute=substitute)

<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>probably.pgcl.simplify &#8212; Probably  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bootstrap-sphinx.css?v=0bf093e7" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/katex-math.css?v=91adb8b6" />
    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/katex.min.js?v=48ec3933"></script>
    <script src="../../../_static/auto-render.min.js?v=8b9f325c"></script>
    <script src="../../../_static/katex_autorenderer.js?v=bebc588a"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;1,400&family=Source+Serif+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        body {
            font: 15px/1.4 "Source Sans Pro",sans-serif;
        }
        h1, h2, h3, h5, h6, h6 {
            font-family: "Source Sans Pro",sans-serif;
        }
        p {
            font-family: "Source Serif Pro",serif;
        }
        .py, .field-list p, pre, code {
            font-family: 'Source Code Pro', monospace;
        }

        /* fix navbar overlaying contents when clicking on anchors */
        :target::before {
            content: "";
            display: block;
            height: 60px; /* fixed header height*/
            margin: -60px 0 0; /* negative fixed header height */
            background: none;
        }

        /* hack to limit the yellow highlight to the the children of the target,
           because of the above hack the target's highlight would be way too large */
        dt:target {
            background-color: transparent;
        }
        dt:target > * {
            background-color: #fbe54e;
        }

        /* spacing adjustments */
        .section {
            margin-bottom: 10rem;
            margin-top: 6rem;
        }
        div.body > .section:first-of-type {
            margin-top: 0rem;
        }
        .class, .function, .data {
            margin-top: 5rem;
            margin-bottom: 7rem;
            border-left: 1px solid #eee;
            padding-left: 1rem;
        }
        dl.attribute > dd, dl.class > dd, dl.function > dd, dl.method > dd {
            margin-left: 30px;
        }
        p {
            margin-top: 1.05em;
            margin-bottom: 1.05em;
            text-align: justify;
        }
        .field-list p, li p {
            text-align: left;
        }
        /* adjust font sizes */
        dl.field-list, dl.attribute {
            font-size: 90%;
        }
        .math {
            font-size: 90.09%;
        }
    </style>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          Probably</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="https://github.com/Philipp15b/probably">GitHub Repository</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Contents <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../pgcl.html"><code class="docutils literal notranslate"><span class="pre">probably.pgcl</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../pgcl.html#compiler-frontend">Compiler Frontend</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../pgcl.html#ast">AST</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../pgcl.html#program">Program</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../pgcl.html#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../pgcl.html#declarations">Declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../pgcl.html#expressions">Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../pgcl.html#instructions">Instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../pgcl.html#superclasses">Superclasses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../pgcl.html#weakest-pre-expectations">Weakest Pre-Expectations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../pgcl.html#loop-free">Loop-Free</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../pgcl.html#transformers">Transformers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../pgcl.html#loops">Loops</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../pgcl.html#program-shapes">Program Shapes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../pgcl.html#linearity">Linearity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../pgcl.html#one-big-loop">One Big Loop</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../pgcl.html#parser">Parser</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../pgcl.html#walking-asts">Walking ASTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../pgcl.html#type-checking">Type Checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../pgcl.html#variable-substitution">Variable Substitution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../pgcl.html#expression-simplification">Expression Simplification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../pgcl.html#control-flow-graph">Control-Flow Graph</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../pysmt.html"><code class="docutils literal notranslate"><span class="pre">probably.pysmt</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../pysmt.html#translation-context">Translation Context</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../pysmt.html#expression-translation">Expression Translation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html"><code class="docutils literal notranslate"><span class="pre">probably.util</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../util.html#mutable-references">Mutable References</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../util.html#lark-expression-parser">Lark Expression Parser</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary">
<h4 style="padding: 5px 20px">Contents</h4>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../pgcl.html"><code class="docutils literal notranslate"><span class="pre">probably.pgcl</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pysmt.html"><code class="docutils literal notranslate"><span class="pre">probably.pysmt</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html"><code class="docutils literal notranslate"><span class="pre">probably.util</span></code></a></li>
</ul>

        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <h1>Source code for probably.pgcl.simplify</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">-------------------------</span>
<span class="sd">Expression Simplification</span>
<span class="sd">-------------------------</span>

<span class="sd">Expressions and expectations become ugly after wp calculation?</span>
<span class="sd">Your program has dumb expressions a toddler could simplify?</span>
<span class="sd">This is the right place for you!</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">attr</span>

<span class="kn">from</span> <span class="nn">probably.util.ref</span> <span class="kn">import</span> <span class="n">Mut</span>

<span class="kn">from</span> <span class="nn">.ast</span> <span class="kn">import</span> <span class="n">VarExpr</span>  <span class="c1"># pylint:disable=unused-import</span>
<span class="kn">from</span> <span class="nn">.ast</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Binop</span><span class="p">,</span> <span class="n">BinopExpr</span><span class="p">,</span> <span class="n">BoolLitExpr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">NatLitExpr</span><span class="p">,</span> <span class="n">NatType</span><span class="p">,</span>
                  <span class="n">Program</span><span class="p">,</span> <span class="n">RealLitExpr</span><span class="p">,</span> <span class="n">RealType</span><span class="p">,</span> <span class="n">SubstExpr</span><span class="p">,</span> <span class="n">TickExpr</span><span class="p">,</span> <span class="n">Unop</span><span class="p">,</span>
                  <span class="n">UnopExpr</span><span class="p">,</span> <span class="n">Var</span><span class="p">,</span> <span class="n">Walk</span><span class="p">,</span> <span class="n">expr_str_parens</span><span class="p">,</span> <span class="n">walk_expr</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.check</span> <span class="kn">import</span> <span class="n">CheckFail</span><span class="p">,</span> <span class="n">get_type</span>
<span class="kn">from</span> <span class="nn">.wp</span> <span class="kn">import</span> <span class="n">ExpectationTransformer</span>


<div class="viewcode-block" id="simplifying_and">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.simplifying_and">[docs]</a>
<span class="k">def</span> <span class="nf">simplifying_and</span><span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine with `Binop.AND`, but simplify when one operand is `BoolLitExpr(True)`.</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; simplifying_and(BoolLitExpr(True), VarExpr(&#39;x&#39;))</span>
<span class="sd">        VarExpr(&#39;x&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">BoolLitExpr</span><span class="p">(</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">rhs</span>
    <span class="k">if</span> <span class="n">rhs</span> <span class="o">==</span> <span class="n">BoolLitExpr</span><span class="p">(</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">lhs</span>
    <span class="k">return</span> <span class="n">BinopExpr</span><span class="p">(</span><span class="n">Binop</span><span class="o">.</span><span class="n">AND</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span></div>



<div class="viewcode-block" id="simplifying_plus">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.simplifying_plus">[docs]</a>
<span class="k">def</span> <span class="nf">simplifying_plus</span><span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine with ``Binop.PLUS``, but simplify when one operand is</span>
<span class="sd">    ``NatLitExpr(0)`` or both operands are ``NatLitExpr``.</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; simplifying_plus(NatLitExpr(0), VarExpr(&#39;x&#39;))</span>
<span class="sd">        VarExpr(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; simplifying_plus(NatLitExpr(5), NatLitExpr(2))</span>
<span class="sd">        NatLitExpr(7)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">NatLitExpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rhs</span>
    <span class="k">elif</span> <span class="n">rhs</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lhs</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">NatLitExpr</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">NatLitExpr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">NatLitExpr</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">rhs</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BinopExpr</span><span class="p">(</span><span class="n">Binop</span><span class="o">.</span><span class="n">PLUS</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span></div>



<div class="viewcode-block" id="simplifying_times">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.simplifying_times">[docs]</a>
<span class="k">def</span> <span class="nf">simplifying_times</span><span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine with ``Binop.TIMES``, but simplify when one operand is ``RealLitExpr(&quot;1.0&quot;)``.</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; simplifying_times(RealLitExpr(&quot;1.0&quot;), VarExpr(&#39;x&#39;))</span>
<span class="sd">        VarExpr(&#39;x&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">one</span> <span class="o">=</span> <span class="n">RealLitExpr</span><span class="p">(</span><span class="s2">&quot;1.0&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rhs</span>
    <span class="k">if</span> <span class="n">rhs</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lhs</span>
    <span class="k">return</span> <span class="n">BinopExpr</span><span class="p">(</span><span class="n">Binop</span><span class="o">.</span><span class="n">TIMES</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span></div>



<div class="viewcode-block" id="simplifying_subst">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.simplifying_subst">[docs]</a>
<span class="k">def</span> <span class="nf">simplifying_subst</span><span class="p">(</span><span class="n">subst</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Expr</span><span class="p">],</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Only create a ``SubstExpr`` around `expr` if `expr` is not a simple literal.</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; simplifying_subst(dict(), RealLitExpr(&quot;1.0&quot;))</span>
<span class="sd">        RealLitExpr(&quot;1.0&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">BoolLitExpr</span><span class="p">,</span> <span class="n">RealLitExpr</span><span class="p">,</span> <span class="n">NatLitExpr</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">return</span> <span class="n">SubstExpr</span><span class="p">(</span><span class="n">subst</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span></div>



<div class="viewcode-block" id="simplifying_neg">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.simplifying_neg">[docs]</a>
<span class="k">def</span> <span class="nf">simplifying_neg</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Negate the given Boolean expression. If we already have a negation, unwrap it.</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; simplifying_neg(UnopExpr(Unop.NEG, VarExpr(&quot;x&quot;)))</span>
<span class="sd">        VarExpr(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; simplifying_neg(VarExpr(&quot;x&quot;))</span>
<span class="sd">        UnopExpr(operator=Unop.NEG, expr=VarExpr(&#39;x&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">UnopExpr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="n">Unop</span><span class="o">.</span><span class="n">NEG</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">expr</span>
    <span class="k">return</span> <span class="n">UnopExpr</span><span class="p">(</span><span class="n">Unop</span><span class="o">.</span><span class="n">NEG</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span></div>



<div class="viewcode-block" id="SnfExpectationTransformerProduct">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.SnfExpectationTransformerProduct">[docs]</a>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">SnfExpectationTransformerProduct</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`SnfExpectationTransformer` represents a list of</span>
<span class="sd">    :class:`SnfExpectationTransformerProduct`.</span>

<span class="sd">    The multiplication operator (``*``) is implemented, and returns the product</span>
<span class="sd">    of two objects. However, only at most one of the operands must have a</span>
<span class="sd">    non-empty set of substitutions.</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; a = SnfExpectationTransformerProduct.from_iverson(BoolLitExpr(True))</span>
<span class="sd">        &gt;&gt;&gt; b = SnfExpectationTransformerProduct(guard=BoolLitExpr(True), prob=RealLitExpr(&quot;5.0&quot;), subst=None, ticks=TickExpr(NatLitExpr(1)))</span>
<span class="sd">        &gt;&gt;&gt; c = SnfExpectationTransformerProduct(guard=BoolLitExpr(False), prob=RealLitExpr(&quot;2.0&quot;), subst=None, ticks=TickExpr(NatLitExpr(5)))</span>
<span class="sd">        &gt;&gt;&gt; print(a * b)</span>
<span class="sd">        [true] * 5.0 * tick(1)</span>
<span class="sd">        &gt;&gt;&gt; print(a * b * c)</span>
<span class="sd">        [false] * (5.0 * 2.0) * tick(6)</span>
<span class="sd">        &gt;&gt;&gt; print(SnfExpectationTransformerProduct(guard=BoolLitExpr(True), prob=RealLitExpr(&quot;2.0&quot;), subst={&quot;x&quot;: VarExpr(&quot;y&quot;)}, ticks=TickExpr(NatLitExpr(0))))</span>
<span class="sd">        [true] * 2.0 * (𝑋)[x/y]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">guard</span><span class="p">:</span> <span class="n">Expr</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The boolean guard expression.&quot;&quot;&quot;</span>

    <span class="n">prob</span><span class="p">:</span> <span class="n">Expr</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The probability without any Iverson brackets or</span>
<span class="sd">    :class:`probably.pgcl.ast.TickExpr`. It has types</span>
<span class="sd">    :class:`probably.pgcl.ast.RealType` or :class:`probably.pgcl.ast.NatType`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">subst</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representing the (optional) post-expectation and substitutions applied to it.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ticks</span><span class="p">:</span> <span class="n">TickExpr</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sum of ticks in this part.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="SnfExpectationTransformerProduct.from_iverson">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.SnfExpectationTransformerProduct.from_iverson">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_iverson</span><span class="p">(</span><span class="n">guard</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SnfExpectationTransformerProduct&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new value ``guard * 1.0 * tick(1)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SnfExpectationTransformerProduct</span><span class="p">(</span><span class="n">guard</span><span class="o">=</span><span class="n">guard</span><span class="p">,</span>
                                                <span class="n">prob</span><span class="o">=</span><span class="n">RealLitExpr</span><span class="p">(</span><span class="s2">&quot;1.0&quot;</span><span class="p">),</span>
                                                <span class="n">subst</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                <span class="n">ticks</span><span class="o">=</span><span class="n">TickExpr</span><span class="p">(</span><span class="n">NatLitExpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span></div>


<div class="viewcode-block" id="SnfExpectationTransformerProduct.from_prob">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.SnfExpectationTransformerProduct.from_prob">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_prob</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SnfExpectationTransformerProduct&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new value from just the probability.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SnfExpectationTransformerProduct</span><span class="p">(</span><span class="n">guard</span><span class="o">=</span><span class="n">BoolLitExpr</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span>
                                                <span class="n">prob</span><span class="o">=</span><span class="n">expr</span><span class="p">,</span>
                                                <span class="n">subst</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                <span class="n">ticks</span><span class="o">=</span><span class="n">TickExpr</span><span class="p">(</span><span class="n">NatLitExpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span></div>


<div class="viewcode-block" id="SnfExpectationTransformerProduct.from_subst">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.SnfExpectationTransformerProduct.from_subst">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_subst</span><span class="p">(</span>
            <span class="n">subst</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Expr</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;SnfExpectationTransformerProduct&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new value from the substitution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SnfExpectationTransformerProduct</span><span class="p">(</span><span class="n">guard</span><span class="o">=</span><span class="n">BoolLitExpr</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span>
                                                <span class="n">prob</span><span class="o">=</span><span class="n">RealLitExpr</span><span class="p">(</span><span class="s2">&quot;1.0&quot;</span><span class="p">),</span>
                                                <span class="n">subst</span><span class="o">=</span><span class="n">subst</span><span class="p">,</span>
                                                <span class="n">ticks</span><span class="o">=</span><span class="n">TickExpr</span><span class="p">(</span><span class="n">NatLitExpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span></div>


<div class="viewcode-block" id="SnfExpectationTransformerProduct.from_ticks">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.SnfExpectationTransformerProduct.from_ticks">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_ticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">:</span> <span class="n">TickExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SnfExpectationTransformerProduct&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new value from ticks.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SnfExpectationTransformerProduct</span><span class="p">(</span><span class="n">guard</span><span class="o">=</span><span class="n">BoolLitExpr</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span>
                                                <span class="n">prob</span><span class="o">=</span><span class="n">RealLitExpr</span><span class="p">(</span><span class="s2">&quot;1.0&quot;</span><span class="p">),</span>
                                                <span class="n">subst</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                <span class="n">ticks</span><span class="o">=</span><span class="n">ticks</span><span class="p">)</span></div>


<div class="viewcode-block" id="SnfExpectationTransformerProduct.substitute">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.SnfExpectationTransformerProduct.substitute">[docs]</a>
    <span class="k">def</span> <span class="nf">substitute</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">subst</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span>
                              <span class="n">Expr</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;SnfExpectationTransformerProduct&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the substitution to this value.</span>

<span class="sd">        This object&#39;s :data:`subst` must be empty!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">subst</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">SnfExpectationTransformerProduct</span><span class="p">(</span>
            <span class="n">guard</span><span class="o">=</span><span class="n">simplifying_subst</span><span class="p">(</span><span class="n">subst</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">guard</span><span class="p">),</span>
            <span class="n">prob</span><span class="o">=</span><span class="n">SubstExpr</span><span class="p">(</span><span class="n">subst</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">),</span>
            <span class="n">subst</span><span class="o">=</span><span class="n">subst</span><span class="p">,</span>
            <span class="n">ticks</span><span class="o">=</span><span class="n">TickExpr</span><span class="p">(</span><span class="n">simplifying_subst</span><span class="p">(</span><span class="n">subst</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ticks</span><span class="o">.</span><span class="n">expr</span><span class="p">)))</span></div>


    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;SnfExpectationTransformerProduct&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SnfExpectationTransformerProduct&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subst</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">subst</span>
                    <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span> <span class="s2">&quot;only one operand may include substitutions&quot;</span>
        <span class="n">subst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subst</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subst</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">other</span><span class="o">.</span><span class="n">subst</span>
        <span class="k">return</span> <span class="n">SnfExpectationTransformerProduct</span><span class="p">(</span>
            <span class="n">guard</span><span class="o">=</span><span class="n">simplifying_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">guard</span><span class="p">),</span>
            <span class="n">prob</span><span class="o">=</span><span class="n">simplifying_times</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">prob</span><span class="p">),</span>
            <span class="n">subst</span><span class="o">=</span><span class="n">subst</span><span class="p">,</span>
            <span class="n">ticks</span><span class="o">=</span><span class="n">TickExpr</span><span class="p">(</span><span class="n">simplifying_plus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ticks</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span>
                                            <span class="n">other</span><span class="o">.</span><span class="n">ticks</span><span class="o">.</span><span class="n">expr</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subst</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subst</span> <span class="o">=</span> <span class="n">SubstExpr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subst</span><span class="p">,</span> <span class="n">VarExpr</span><span class="p">(</span><span class="s1">&#39;𝑋&#39;</span><span class="p">))</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">subst</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ticks</span><span class="o">.</span><span class="n">is_zero</span><span class="p">():</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ticks</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">guard</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span> <span class="n">expr_str_parens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot; * &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span></div>



<div class="viewcode-block" id="SnfExpectationTransformer">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.SnfExpectationTransformer">[docs]</a>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">SnfExpectationTransformer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An expectation transformer</span>
<span class="sd">    (:class:`probably.pgcl.wp.ExpectationTransformer`) is in *summation normal</span>
<span class="sd">    form (SNF)* if it is a sum of products</span>
<span class="sd">    (:class:`SnfExpectationTransformerProduct`). This class can be accessed just</span>
<span class="sd">    like a list over :class:`SnfExpectationTransformerProduct`.</span>

<span class="sd">    You can create a summation normal form expectation transformer from an</span>
<span class="sd">    :class:`Expr` using :func:`normalize_expectation_transformer`.</span>

<span class="sd">    The multiplication operator is implemented (``*``), but only one operand may</span>
<span class="sd">    include substitutions. This is always the case for transformers generated</span>
<span class="sd">    from weakest pre-expectation semantics (see :mod:`probably.pgcl.wp`).</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; a = SnfExpectationTransformerProduct.from_iverson(BoolLitExpr(True))</span>
<span class="sd">        &gt;&gt;&gt; b = SnfExpectationTransformerProduct.from_prob(RealLitExpr(&quot;0.5&quot;))</span>
<span class="sd">        &gt;&gt;&gt; c = SnfExpectationTransformerProduct.from_subst({&quot;x&quot;: VarExpr(&quot;y&quot;)})</span>
<span class="sd">        &gt;&gt;&gt; print(SnfExpectationTransformer([a, b, c]))</span>
<span class="sd">        λ𝑋. [true] * 1.0 + [true] * 0.5 + [true] * 1.0 * (𝑋)[x/y]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SnfExpectationTransformerProduct</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SnfExpectationTransformerProduct</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">values</span>

        <span class="c1"># To catch bugs, verify that the probability expressions do not contain Iverson brackets.</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child_ref</span> <span class="ow">in</span> <span class="n">walk_expr</span><span class="p">(</span><span class="n">Walk</span><span class="o">.</span><span class="n">DOWN</span><span class="p">,</span> <span class="n">Mut</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">prob</span><span class="p">)):</span>
                <span class="n">child</span> <span class="o">=</span> <span class="n">child_ref</span><span class="o">.</span><span class="n">val</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">UnopExpr</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="n">Unop</span><span class="o">.</span><span class="n">IVERSON</span><span class="p">)</span>

<div class="viewcode-block" id="SnfExpectationTransformer.from_iverson">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.SnfExpectationTransformer.from_iverson">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_iverson</span><span class="p">(</span><span class="n">guard</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SnfExpectationTransformer&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new value ``guard * 1.0 * tick(1)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SnfExpectationTransformer</span><span class="p">(</span>
            <span class="p">[</span><span class="n">SnfExpectationTransformerProduct</span><span class="o">.</span><span class="n">from_iverson</span><span class="p">(</span><span class="n">guard</span><span class="p">)])</span></div>


<div class="viewcode-block" id="SnfExpectationTransformer.from_prob">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.SnfExpectationTransformer.from_prob">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_prob</span><span class="p">(</span><span class="n">expectation</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SnfExpectationTransformer&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new value with just the probability.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SnfExpectationTransformer</span><span class="p">(</span>
            <span class="p">[</span><span class="n">SnfExpectationTransformerProduct</span><span class="o">.</span><span class="n">from_prob</span><span class="p">(</span><span class="n">expectation</span><span class="p">)])</span></div>


<div class="viewcode-block" id="SnfExpectationTransformer.from_subst">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.SnfExpectationTransformer.from_subst">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_subst</span><span class="p">(</span><span class="n">subst</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Expr</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;SnfExpectationTransformer&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new value with just the substitution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SnfExpectationTransformer</span><span class="p">(</span>
            <span class="p">[</span><span class="n">SnfExpectationTransformerProduct</span><span class="o">.</span><span class="n">from_subst</span><span class="p">(</span><span class="n">subst</span><span class="p">)])</span></div>


<div class="viewcode-block" id="SnfExpectationTransformer.from_ticks">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.SnfExpectationTransformer.from_ticks">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_ticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">:</span> <span class="n">TickExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SnfExpectationTransformer&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new value with just the ticks value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SnfExpectationTransformer</span><span class="p">(</span>
            <span class="p">[</span><span class="n">SnfExpectationTransformerProduct</span><span class="o">.</span><span class="n">from_ticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">)])</span></div>


<div class="viewcode-block" id="SnfExpectationTransformer.substitute">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.SnfExpectationTransformer.substitute">[docs]</a>
    <span class="k">def</span> <span class="nf">substitute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subst</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span>
                                     <span class="n">Expr</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;SnfExpectationTransformer&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the subtitution to this expectation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SnfExpectationTransformer</span><span class="p">(</span>
            <span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">subst</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>


    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;SnfExpectationTransformer&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SnfExpectationTransformer&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SnfExpectationTransformer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;SnfExpectationTransformer&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SnfExpectationTransformer&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SnfExpectationTransformer</span><span class="p">(</span>
            <span class="p">[</span><span class="n">lhs</span> <span class="o">*</span> <span class="n">rhs</span> <span class="k">for</span> <span class="n">lhs</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="s2">&quot; + &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;λ𝑋. </span><span class="si">{</span><span class="n">terms</span><span class="si">}</span><span class="s2">&quot;</span></div>



<div class="viewcode-block" id="normalize_expectation_transformer">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.normalize_expectation_transformer">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_expectation_transformer</span><span class="p">(</span>
    <span class="n">program</span><span class="p">:</span> <span class="n">Program</span><span class="p">,</span> <span class="n">expectation_transformer</span><span class="p">:</span> <span class="n">ExpectationTransformer</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">SnfExpectationTransformer</span><span class="p">,</span> <span class="n">CheckFail</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a well-typed expectation transformer, return a</span>
<span class="sd">    :class:`SnfExpectationTransformer`, i.e. an expectation transformer in</span>
<span class="sd">    *summation normal form* (SNF).</span>

<span class="sd">    Important: A guard statement may only appear in sums and products, but not</span>
<span class="sd">    anywhere in the operands of a minus.</span>

<span class="sd">    Simplifying methods are used whenever possible: :func:`simplifying_and`,</span>
<span class="sd">    :func:`simplifying_plus`, :func:`simplifying_times`, and</span>
<span class="sd">    :func:`simplifying_subst`.</span>

<span class="sd">    See :func:`normalize_expectation` for a lot of examples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">recurse</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">SnfExpectationTransformer</span><span class="p">,</span> <span class="n">CheckFail</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">BinopExpr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="n">Binop</span><span class="o">.</span><span class="n">PLUS</span><span class="p">:</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">recurse</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">CheckFail</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">lhs</span>

                <span class="c1"># addition with a TickExpr is handled explicitely to get a nicer</span>
                <span class="c1"># result. without the following branch (it is entirely an</span>
                <span class="c1"># optimization), we&#39;d get something like: `[x &lt; n] * 1/2 *</span>
                <span class="c1"># (𝑋)[r/0, x/x + 0] + [x &lt; n] * 1/2 * tick(1)` instead of `[x &lt;</span>
                <span class="c1"># n] * 1/2 * ((𝑋)[r/0, x/x + 0] + tick(1))`.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">TickExpr</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">lhs</span><span class="p">:</span>
                        <span class="n">value</span><span class="o">.</span><span class="n">ticks</span> <span class="o">=</span> <span class="n">TickExpr</span><span class="p">(</span>
                            <span class="n">simplifying_plus</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">ticks</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">expr</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">lhs</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rhs</span> <span class="o">=</span> <span class="n">recurse</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">CheckFail</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">rhs</span>
                <span class="k">return</span> <span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="n">Binop</span><span class="o">.</span><span class="n">TIMES</span><span class="p">:</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">recurse</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">CheckFail</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">lhs</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">recurse</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">CheckFail</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">rhs</span>
                <span class="k">return</span> <span class="n">lhs</span> <span class="o">*</span> <span class="n">rhs</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">UnopExpr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="n">Unop</span><span class="o">.</span><span class="n">IVERSON</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SnfExpectationTransformer</span><span class="o">.</span><span class="n">from_iverson</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="n">Unop</span><span class="o">.</span><span class="n">NEG</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;negation operator is not applicable to expectations&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">SubstExpr</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span>
                <span class="n">VarExpr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">var</span> <span class="o">==</span> <span class="n">expectation_transformer</span><span class="o">.</span><span class="n">variable</span>
            <span class="k">return</span> <span class="n">SnfExpectationTransformer</span><span class="o">.</span><span class="n">from_subst</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">subst</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">TickExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SnfExpectationTransformer</span><span class="o">.</span><span class="n">from_ticks</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="c1"># the last remaining cases are only VarExprs and literals.</span>
        <span class="n">expr_type</span> <span class="o">=</span> <span class="n">get_type</span><span class="p">(</span><span class="n">program</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr_type</span><span class="p">,</span> <span class="n">CheckFail</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">expr_type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr_type</span><span class="p">,</span> <span class="p">(</span><span class="n">RealType</span><span class="p">,</span> <span class="n">NatType</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">SnfExpectationTransformer</span><span class="o">.</span><span class="n">from_prob</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;unreachable&quot;</span><span class="p">)</span>

    <span class="n">expectation_transformer</span><span class="o">.</span><span class="n">substitute</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">recurse</span><span class="p">(</span><span class="n">expectation_transformer</span><span class="o">.</span><span class="n">expectation</span><span class="p">)</span></div>



<div class="viewcode-block" id="normalize_expectation">
<a class="viewcode-back" href="../../../pgcl.html#probably.pgcl.simplify.normalize_expectation">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_expectation</span><span class="p">(</span>
        <span class="n">program</span><span class="p">:</span> <span class="n">Program</span><span class="p">,</span>
        <span class="n">expectation</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">SnfExpectationTransformer</span><span class="p">,</span> <span class="n">CheckFail</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specialized version of :func:`normalize_expectation_transformer`.</span>

<span class="sd">    Translate this expectation into summation normal form. The result is a</span>
<span class="sd">    :class:`SnfExpectationTransformer` where</span>
<span class="sd">    :data:`SnfExpectationTransformerProduct.subst` are always empty.</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; from .ast import *</span>
<span class="sd">        &gt;&gt;&gt; from .parser import parse_pgcl, parse_expectation</span>
<span class="sd">        &gt;&gt;&gt; program = parse_pgcl(&quot;bool x; nat c&quot;)</span>

<span class="sd">        &gt;&gt;&gt; expectation = parse_expectation(&quot;[true] * ([false] + 1.0)&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(normalize_expectation(program, expectation))</span>
<span class="sd">        λ𝑋. [false] * 1.0 + [true] * 1.0</span>

<span class="sd">        &gt;&gt;&gt; prob = RealLitExpr(&quot;10&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(normalize_expectation(program, BinopExpr(Binop.TIMES, prob, prob)))</span>
<span class="sd">        λ𝑋. [true] * (10 * 10)</span>

<span class="sd">        &gt;&gt;&gt; normalize_expectation(program, BinopExpr(Binop.TIMES, UnopExpr(Unop.IVERSON, VarExpr(&#39;x&#39;)), prob))</span>
<span class="sd">        [SnfExpectationTransformerProduct(guard=VarExpr(&#39;x&#39;), prob=RealLitExpr(&quot;10&quot;), subst=None, ticks=TickExpr(expr=NatLitExpr(0)))]</span>

<span class="sd">        &gt;&gt;&gt; expectation = parse_expectation(&quot;[c &lt; 3] * c&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(normalize_expectation(program, expectation))</span>
<span class="sd">        λ𝑋. [c &lt; 3] * c</span>

<span class="sd">        &gt;&gt;&gt; expectation = parse_expectation(&quot;1 - 5&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(normalize_expectation(program, expectation))</span>
<span class="sd">        λ𝑋. [true] * (1 - 5)</span>

<span class="sd">        &gt;&gt;&gt; expectation = parse_expectation(&quot;c - 0.5&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(normalize_expectation(program, expectation))</span>
<span class="sd">        λ𝑋. [true] * (c - 0.5)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="s1">&#39;𝑋&#39;</span>
    <span class="k">assert</span> <span class="n">variable</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">program</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;can&#39;t use 𝑋 as a variable name&quot;</span>
    <span class="n">transformer</span> <span class="o">=</span> <span class="n">ExpectationTransformer</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">expectation</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">normalize_expectation_transformer</span><span class="p">(</span><span class="n">program</span><span class="p">,</span> <span class="n">transformer</span><span class="p">)</span></div>

</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2024, Philipp Schröer.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.2.6.<br/>
    </p>
  </div>
</footer>
  </body>
</html>